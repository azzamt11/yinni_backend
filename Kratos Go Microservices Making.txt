Kratos Go Microservices Making:
==================================================================


#Step 1: Making a main app directory
kratos new yinni_backend


#Step 2: Go to dir and open Code
cd yinni_backend
code .


#Step 3: Make new service inside the main app directory, with no mod
kratos new app/user --nomod 


#Step 4: Make the proto file
kratos proto add api/user/v1/user.proto
--build the proto file just like in the example


#Step 5: Build proto to api file
kratos proto client api/helloworld/demo.proto
--add this file to third_party/options
```
syntax = "proto3";

package gorm;

option go_package = "github.com/infobloxopen/protoc-gen-gorm/options;gorm";

import "google/protobuf/descriptor.proto";

// TODO: The option number 52119 lies within the internally reserved extension
// range. I believe a publicly unique number should be requested.

// Currently no file options
extend google.protobuf.FileOptions {
  GormFileOptions file_opts = 52119;
}

message GormFileOptions {
}

// Validation rules applied at the message level
extend google.protobuf.MessageOptions {
    // ormable will cause orm code to be generated for this message/object
    GormMessageOptions opts = 52119;
}

message GormMessageOptions {
  bool ormable = 1;
  repeated ExtraField include = 2;
  string table = 3;
  bool multi_account = 4;
  bool multi_compartment = 5;
}

message ExtraField {
  string type = 1;
  string name = 2;
  GormTag tag = 3;
  string package = 4;
}

// Field level specifications
extend google.protobuf.FieldOptions {
    GormFieldOptions field = 52119;
}

message GormFieldOptions {
    GormTag tag = 1;
    bool drop = 2;
    oneof association {
        HasOneOptions has_one = 3;
        BelongsToOptions belongs_to = 4;
        HasManyOptions has_many = 5;
        ManyToManyOptions many_to_many = 6;
    }
    string reference_of = 7;
}

message GormTag {
    string column = 1;
    string type = 2;
    int32 size = 3;
    int32 precision = 4;
    bool primary_key = 5;
    bool unique = 6;
    string default = 7;
    bool not_null = 8;
    bool auto_increment = 9;
    string index = 10;
    string unique_index = 11;
    bool embedded = 12;
    string embedded_prefix = 13;
    bool ignore = 14;
    string foreignkey = 15;
    string association_foreignkey = 16;
    string many_to_many = 17;
    string jointable_foreignkey = 18;
    string association_jointable_foreignkey = 19;
    bool disable_association_autoupdate = 20;
    bool disable_association_autocreate = 21;
    bool association_save_reference = 22;
    bool preload = 23;
    string serializer = 24;
}

message HasOneOptions {
    string foreignkey = 1;
    GormTag foreignkey_tag = 2;
    string association_foreignkey = 3;
    bool disable_association_autoupdate = 4;
    bool disable_association_autocreate = 5;
    bool association_save_reference = 6;
    bool preload = 7;
    bool replace = 8;
    bool append = 9;
    bool clear = 10;
}

message BelongsToOptions {
    string foreignkey = 1;
    GormTag foreignkey_tag = 2;
    string association_foreignkey = 3;
    bool disable_association_autoupdate = 4;
    bool disable_association_autocreate = 5;
    bool association_save_reference = 6;
    bool preload = 7;
}

message HasManyOptions {
    string foreignkey = 1;
    GormTag foreignkey_tag = 2;
    string association_foreignkey = 3;
    string position_field = 4;
    GormTag position_field_tag = 5;
    bool disable_association_autoupdate = 6;
    bool disable_association_autocreate = 7;
    bool association_save_reference = 8;
    bool preload = 9;
    bool replace = 10;
    bool append = 11;
    bool clear = 12;
}

message ManyToManyOptions {
    string jointable = 1;
    string foreignkey = 2;
    string jointable_foreignkey = 3;
    string association_foreignkey = 4;
    string association_jointable_foreignkey = 5;
    bool disable_association_autoupdate = 6;
    bool disable_association_autocreate = 7;
    bool association_save_reference = 8;
    bool preload = 9;
    bool replace = 10;
    bool append = 11;
    bool clear = 13;
}


// To be used in (leiu of) the interceptor
extend google.protobuf.ServiceOptions {
  AutoServerOptions server = 52119;
}

message AutoServerOptions {
  bool autogen = 1;
  bool txn_middleware = 2;
  bool with_tracing = 3;
}

extend google.protobuf.MethodOptions {
  MethodOptions method = 52119;
}

message MethodOptions {
  string object_type = 1;
}
```
--Install protoc here: https://github.com/protocolbuffers/protobuf/releases


#Step 6: Build service from proto
kratos proto server api/user/v1/user.proto -t internal/service 


#Step 7: Ent
go install entgo.io/ent/cmd/ent@latest
ent new User
--add this to the schema
```
package schema

import (
    "entgo.io/ent"
    "entgo.io/ent/schema/field"
)

// Fields of the User.
func (User) Fields() []ent.Field {
    return []ent.Field{
        field.Int("age").
            Positive(),
        field.String("name").
            Default("unknown"),
    }
}
```
go generate ./ent
ent generate ./ent/schema
--update go mod and go sum


#Step 8: Change the internal/data/data.go
```
package data

import (
    "context"
    "yinni_backend/ent" // Import your generated ent code
    "yinni_backend/internal/conf"

    "github.com/go-kratos/kratos/v2/log"
    "github.com/google/wire"

    // Import the database driver
    _ "github.com/go-sql-driver/mysql" 
)

// ProviderSet is data providers.
var ProviderSet = wire.NewSet(NewData, NewGreeterRepo)

// Data .
type Data struct {
    db *ent.Client // Add this field
}

// NewData .
func NewData(c *conf.Data, logger log.Logger) (*Data, func(), error) {
    helper := log.NewHelper(logger)

    // 1. Initialize Ent Client
    client, err := ent.Open(
        c.Database.Driver,
        c.Database.Source,
    )
    if err != nil {
        helper.Errorf("failed opening connection to db: %v", err)
        return nil, nil, err
    }

    // 2. Run the auto migration (optional but recommended during development)
    if err := client.Schema.Create(context.Background()); err != nil {
        helper.Errorf("failed creating schema resources: %v", err)
        return nil, nil, err
    }

    d := &Data{
        db: client,
    }

    // 3. Update cleanup to close the database connection
    cleanup := func() {
        helper.Info("closing the data resources")
        if err := d.db.Close(); err != nil {
            helper.Error(err)
        }
    }

    return d, cleanup, nil
}
```
--Update your go sum and go mod


#Step 9: Syncronize with the cmd/wire_gen.go
go generate ./...


#Step 10: Refine the user.proto to make some functionals
```
syntax = "proto3";

package api.user.v1;

import "google/api/annotations.proto";

option go_package = "yinni_backend/api/user/v1;v1";
option java_multiple_files = true;
option java_package = "api.user.v1";

service User {
    rpc CreateUser (CreateUserRequest) returns (CreateUserReply) {
        option (google.api.http) = {
            post: "/user",
            body: "*"
        };
    }
    rpc UpdateUser (UpdateUserRequest) returns (UpdateUserReply) {
        option (google.api.http) = {
            put: "/user/{id}",
            body: "*"
        };
    }
    rpc DeleteUser (DeleteUserRequest) returns (DeleteUserReply) {
        option (google.api.http) = {
            delete: "/user/{id}"
        };
    }
    rpc GetUser (GetUserRequest) returns (GetUserReply) {
        option (google.api.http) = {
            get: "/user/{id}"
        };
    }
    rpc ListUser (ListUserRequest) returns (ListUserReply) {
        option (google.api.http) = {
            get: "/user"
        };
    }
}

message CreateUserRequest {
    string name = 1;
    int32 age = 2;
    string email = 3;
}
message CreateUserReply {
    int64 id = 1;
}

message UpdateUserRequest {
    int64 id = 1; // REQUIRED: Maps to {id} in the URL
    string name = 2;
    int32 age = 3;
    string email = 4;
}
message UpdateUserReply {
    int64 id = 1;
}

message DeleteUserRequest {
    int64 id = 1;
}
message DeleteUserReply {
    int64 id = 1;
}

message GetUserRequest {
    int64 id = 1;
}
message GetUserReply {
    int64 id = 1;
    string name = 2;
    string email = 3;
    int32 age = 4;
}

message ListUserRequest {}
message ListUserReply {
    repeated GetUserReply results = 1; // Returns a list of users
}
```
kratos proto client api/helloworld/demo.proto
kratos proto server api/user/v1/user.proto -t internal/service 
go generate ./...



#Step 11: Run using docker
--Change the database section in config.yaml to this:
```
data:
  database:
    driver: mysql
    source: root:root@tcp(mysql:3306)/test?parseTime=True&loc=Local
```
--and run via docker-compose.yml:
```
services:
  mysql:
    image: mysql:8.0
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: yinni_db
    ports:
      - "3306:3306"
    healthcheck:
      test: ["CMD", "mysqladmin" ,"ping", "-h", "localhost"]
      timeout: 20s
      retries: 10

  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
      - "9000:9000"
    volumes:
      - ./configs:/data/conf
    depends_on:
      mysql:
        condition: service_healthy
    environment:
      - DB_SOURCE=root:root@tcp(mysql:3306)/yinni_db?parseTime=True
```
docker-compose up --build -d


#Step 12: The minimum change you need to make the services build in a separate containers
--on the Dockerfile on each services, after RUN GOPROXY=https://goproxy.cn:
```
go build -o /src/bin/server ./app/user/cmd/user/main.go
```
--The modified docker-compose.yml:
```
services:
  user-service:
    build:
      context: .              # Key: Still use the root directory
      dockerfile: app/user/Dockerfile
    ports:
      - "8000:8000"
      - "9000:9000"
    volumes:
      - ./app/user/configs:/data/conf
    depends_on:
      mysql:
        condition: service_healthy

  order-service:
    build:
      context: .              # Key: Still use the root directory
      dockerfile: app/order/Dockerfile
    ports:
      - "8001:8000"           # Different host port, same container port
      - "9001:9000"
    volumes:
      - ./app/order/configs:/data/conf
    depends_on:
      mysql:
        condition: service_healthy

  mysql:
    image: mysql:8.0
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: yinni_db
    ports:
      - "3306:3306"
    healthcheck:
      test: ["CMD", "mysqladmin" ,"ping", "-h", "localhost"]
      timeout: 5s
      retries: 5
```


#Step 13: Error
--On the build, you might got:
```
0.567 go: errors parsing go.mod:
0.567 /src/go.mod:3: invalid go version '1.25.0': must match format 1.23
0.568 make: *** [Makefile:50: build] Error 1
```
--modify your version to match your compiler version


#Step 14: Error
--On the build, you might got:
```
Error response from daemon: failed to create task for container: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: error during container init: exec: "./server": stat ./server: no such file or directory: unknown
```
--Add this line to run the correct binary name between build and ports docker-compose.yml
```
    command: ["./yinni_backend", "-conf", "/data/conf"] 
```
--Change this line in the Dockerfile:
```
RUN GOPROXY=https://goproxy.cn make build
```
--To this (bypass Makefile to ensure the name is 'server'):
```
RUN GOPROXY=https://goproxy.cn go build -o /src/bin/server ./cmd/yinni_backend/main.go
```


#Step 15:
--Use this docker-compose.yml to make it microservices:
```
services:
  # --- User Microservice ---
  user-service:
    build:
      context: .
      dockerfile: app/user/Dockerfile
    # Override: Run the 'user' binary specifically
    command: ["./user", "-conf", "/data/conf"]
    ports:
      - "8000:8000" # HTTP
      - "9000:9000" # gRPC
    volumes:
      - ./app/user/configs:/data/conf
    depends_on:
      mysql:
        condition: service_healthy

  # --- Order Microservice ---
  # order-service:
  #   build:
  #     context: .
  #     dockerfile: Dockerfile
  #   # Override: Run the 'order' binary specifically
  #   command: ["./order", "-conf", "/data/conf"]
  #   ports:
  #     - "8001:8000" # Maps Host 8001 to Order's HTTP 8000
  #     - "9001:9000" # Maps Host 9001 to Order's gRPC 9000
  #   volumes:
  #     - ./app/order/configs:/data/conf
  #   depends_on:
  #     mysql:
  #       condition: service_healthy

  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: yinni_db
    ports:
      - "3306:3306"
    healthcheck:
      test: ["CMD", "mysqladmin" ,"ping", "-h", "localhost"]
      timeout: 10s
      retries: 5
```
--Change this line in the user service Dockerfile:
```
RUN GOPROXY=https://goproxy.cn make build
```
--into this line:
```
RUN go install github.com/google/wire/cmd/wire@latest
RUN cd app/user/cmd/user && /go/bin/wire
RUN GOPROXY=https://goproxy.cn go build -o /src/bin/server ./app/user/cmd/user/
```
--and this line:
```
COPY --from=builder /src/bin /app
```
--into this line:
```
COPY --from=builder /src/bin/server /app/server
```
--and make sure the last line in the user Dockerfile is:
```
CMD ["./server", "-conf", "/data/conf"]
```
--user/Config:
```
server:
  http:
    addr: 0.0.0.0:8000
    timeout: 1s
  grpc:
    addr: 0.0.0.0:9000
    timeout: 1s
data:
  database:
    driver: mysql
    source: root:root@tcp(mysql:3306)/test?parseTime=True&loc=Local
  redis:
    addr: 127.0.0.1:6379
    read_timeout: 0.2s
    write_timeout: 0.2s
```


#Step 16: Test
--Create:
```
curl -X POST http://localhost:8000/user -H "Content-Type: application/json" -d "{\"name\": \"Gemini User\", \"email\": \"test@example.com\", \"age\": 25}"
```
--Get:
```
curl -X GET http://localhost:8000/user/1
```
--List Get:
```
curl -X GET http://localhost:8000/user
```
--Update:
```
curl -X PUT http://localhost:8000/user/1 -H "Content-Type: application/json" -d "{\"name\": \"Updated Name\", \"age\": 26}"
```
--Delete:
```
curl -X DELETE http://localhost:8000/user/1
```


#Step 17: Building biz (Business Logic)
kratos proto server api/user/v1/user.proto -t app/user/internal/service
--Go precisely in this order:
--1. Modify app/user/internal/biz/user.go (previously greeter.go)
--2. Modify app/user/internal/biz/biz.go
--3. Modify app/user/internal/data/user.go (previously greeter.go)
--4. Modify app/user/internal/data/data.go
--5. Modify app/user/internal/service/user.go: Add a usecase in the constructor, along with the corresponding import:
```
pb *biz.UserUsecase
```
--6. Modify app/user/internal/server/http.go (change import first)
--7. Modify app/user/internal/server/grpc.go (change import first)
--8. Modify app/user/internal/service/service.go
go generate ./...


#Step 18: Refining The Logic (biz/user.go)
--Make sure that the User model struct in biz/user.go match to the proto
```
type User struct {
	ID        int64
	Name      string
	Age       int  <== This follows from the definition we have made in the ent
	Email     string
	CreatedAt time.Time
	UpdatedAt time.Time
}
```
--Adding the logger:
```
type UserUsecase struct {
	repo UserRepo
	log  *log.Helper  <=== This log is from the "github.com/go-kratos/kratos/v2/log"
}

// NewUserUsecase new a User usecase.
func NewUserUsecase(repo UserRepo, logger log.Logger) *UserUsecase {
	return &UserUsecase{repo: repo, log: log.NewHelper(logger)}  <== Pass here
}
```
--Make sure that the functions is correspond to the constructor:
```
func (uc *UserUsecase) CreateUser(ctx context.Context, u *User) (*User, error) {
	log.Infof("CreateUser: %v", u.Email)
	return uc.repo.Create(ctx, u)
}

func (uc *UserUsecase) UpdateUser(ctx context.Context, u *User) (*User, error) {
	log.Infof("UpdateUser: %v", u.Email)
	return uc.repo.Update(ctx, u)
}

func (uc *UserUsecase) DeleteUser(ctx context.Context, id int64) (*User, error) {
	log.Infof("DeleteUser: %v", id)
	return uc.repo.Delete(ctx, id)
}

func (uc *UserUsecase) GetUser(ctx context.Context, id int64) (*User, error) {
	log.Infof("GetUser: %v", id)
	return uc.repo.GetUser(ctx, id)
}

func (uc *UserUsecase) ListAllUser(ctx context.Context) ([]*User, error) {
	log.Infof("ListAllUser: %v")
	return uc.repo.ListAllUser(ctx)
}
```


#Step 19: Defining the database fetching (data/data.go)
--Add the logic of fetching data via ent in the NewData
```
log := log.NewHelper(logger)

client, err := ent.Open(
  "mysql",
  c.Database.Source,
)

if err != nil {
  return nil, nil, err
}

if err := client.Schema.Create(context.Background()); err != nil {
  return nil, nil, err
}
```
--And make sure that we have already register the ent in the constructor:
```
ent *ent.Client
```
go generate ./...


#Step 20: Business Logic Concept
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  transport  â”‚  â† HTTP / gRPC / MQ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   service   â”‚  â† DTO mapping, validation
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     biz     â”‚  â† ðŸ’¡ BUSINESS MEANING
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     data    â”‚  â† DB / cache / external API
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


#Step 21: Building repo functions by ent implementation at data/user.go (biz --> DB --> biz)
--Create:
```
func (r *userRepo) Create(ctx context.Context, g *biz.User) (*biz.User, error) {
	row, err := r.data.ent.User.
		Create().
		SetName(g.Name).
		SetAge(g.Age).
		SetEmail(g.Email).
		Save(ctx)

	if err != nil {
		return nil, err
	}

	return &biz.User{
		ID:    int64(row.ID),
		Name:  row.Name,
		Age:   row.Age,
		Email: row.Email,
	}, nil
}
```
--Update:
```
func (r *userRepo) Update(ctx context.Context, g *biz.User) (*biz.User, error) {
	row, err := r.data.ent.User.
		UpdateOneID(int(g.ID)).
		SetName(g.Name).
		SetAge(g.Age).
		SetEmail(g.Email).
		Save(ctx)

	if err != nil {
		return nil, err
	}

	return &biz.User{
		ID:    int64(row.ID),
		Name:  row.Name,
		Age:   row.Age,
		Email: row.Email,
	}, nil
}
```
--GetUser:
```
func (r *userRepo) GetUser(ctx context.Context, id int64) (*biz.User, error) {
	row, err := r.data.ent.User.Get(ctx, int(id))

	if err != nil {
		return nil, err
	}

	return &biz.User{
		ID:    int64(row.ID),
		Name:  row.Name,
		Age:   row.Age,
		Email: row.Email,
	}, nil
}
```
--Delete:
```
func (r *userRepo) Delete(ctx context.Context, id int64) (*biz.User, error) {
	err := r.data.ent.User.DeleteOneID(int(id)).Exec(ctx)
	return nil, err
}
```
--GetList:
```
func (r *userRepo) ListAllUser(ctx context.Context) ([]*biz.User, error) {
	rows, err := r.data.ent.User.Query().All(ctx)

	if err != nil {
		return nil, err
	}

	rv := make([]*biz.User, 0, len(rows))
	for _, row := range rows {
		rv = append(rv, &biz.User{
			ID:    int64(row.ID),
			Name:  row.Name,
			Age:   row.Age,
			Email: row.Email,
		})
	}
	return rv, nil
}
```
--Simply just do query --> err catching --> bizUser parsing


#Step 22: Building service functions at service/user.go (req --> biz --> rep)
--All you do is just simple. Pass the req.User to repo.function and then pass the result from the repo to the reply.


#Step 23: Dont forget the \api\user\v1\user_error_reason.proto.

#Step 24: Error:
docker logs yinni_backend-user-service-1
--If you find error, you might want to add this line _ "github.com/go-sql-driver/mysql" on the app/user/cmd/user/main.go.
--or replace test?parseTime=True&loc=Local in config by yinni_db?parseTime=true&charset=utf8mb4&loc=Local

#Step 24: CORS
--On CORS error while testing, add the import "github.com/rs/cors" on the internal/server/http.go
--And add this line before the var.opts:
```
corsHandler := cors.New(cors.Options{
		AllowedOrigins:   []string{"*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"*"},
		AllowCredentials: true,
	})
```
--and this:
```
http.Filter(corsHandler.Handler),
```
--after the http.middleware

#Step 25: Error Fixing
--Make sure that the service/user.go constructor is like this
```
type UserService struct {
	pb.UnimplementedUserServer

	uc *biz.UserUsecase
}
```
--And all the corresponding is match, including one in the constructor argument
```
func NewUserService(uc *biz.UserUsecase) *UserService {
	return &UserService{uc: uc}
}
```
go generate ./...


